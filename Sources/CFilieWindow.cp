#include "CFilieWindow.h"#include "CListManagerWindowAttachment.h"#include <string.h>#include <limits.h>/*OSErr AppendIndFilenameInFolder(short vRefNum, short dirID, short dirIndex) {	CInfoPBRec	catInfo = {0};	Str255		fileNameBuffer = {0};	Str255		errStr = {0};	OSErr		err = noErr;	Boolean		isFolder = false;	int			x = 0;		fileNameBuffer[0] = 0;	catInfo.dirInfo.ioVRefNum = vRefNum;	catInfo.dirInfo.ioDrDirID = dirID;	catInfo.dirInfo.ioFDirIndex = dirIndex;	catInfo.dirInfo.ioNamePtr = fileNameBuffer;		err = PBGetCatInfoSync(&catInfo);	if (err == fnfErr) { // Past last file.		RemoveTrailingReturnFromReturnValue();		return err;	} else if (err != noErr) {		NumToString(err, errStr);		SetReturnValue("\pError getting next file: ");		AppendReturnValue(errStr);		return err;	}	if ((catInfo.hFileInfo.ioFlFndrInfo.fdFlags & fInvisible) == fInvisible) { // Skip invisible files.		return noErr;	}		for (x = 1; x <= fileNameBuffer[0]; ++x) { // Skip files with "invalid" names like "Icon\r" file used to store custom icons.		if (fileNameBuffer[x] == '\r') {			return noErr;		}	}		isFolder = (catInfo.hFileInfo.ioFlAttrib & kFolderBit) == kFolderBit;	AppendReturnValueChars(dirPath);	if (dirPathLength > 0 && (*dirPath)[dirPathLength - 1] != ':') {		AppendReturnValue("\p:");	}	AppendReturnValue(fileNameBuffer);	if (isFolder) {		AppendReturnValue("\p:foldMACS\r");	} else {		AppendReturnValue("\p:");		AppendReturnValueBytes(4, &catInfo.hFileInfo.ioFlFndrInfo.fdType);		AppendReturnValueBytes(4, &catInfo.hFileInfo.ioFlFndrInfo.fdCreator);		AppendReturnValue("\p\r");	}		return noErr;}*/void CFilieWindow::CreateWindow() {	CWindow::CreateWindow();	Rect listRect = mWindow->portRect;	mList = new CListManagerWindowAttachment(this, &listRect);	mList->SetAutoPositionFlags(kAutoPositionFlagResizeHorz | kAutoPositionFlagResizeVert);		// fsRtParID		HParamBlockRec paramBlock = {};	Str255 volName = {};	paramBlock.volumeParam.ioNamePtr = volName;		for (paramBlock.volumeParam.ioVolIndex = 1; paramBlock.volumeParam.ioVolIndex <= SHRT_MAX; ++paramBlock.volumeParam.ioVolIndex) {		OSErr err = PBHGetVInfo(&paramBlock, false);		if (err != noErr) {			break;		}				mList->AddRow(volName + 1, volName[0]);	}}