#include <Controls.h>#include <QuickDraw.h>#include <string.h>#include "ListControl.h"#include "ListControlPrivate.h"void HandleDraw(short varCode, ControlHandle theControl, short partCode) {	ListControlDataHandle dataHandle = (ListControlDataHandle) (**theControl).contrlData;	ListHandle list = (**dataHandle).list;	ForeColor(whiteColor);	PaintRect(&(**theControl).contrlRect);		LUpdate((**list).port->visRgn, list);		ForeColor(blackColor);	FrameRect(&(**theControl).contrlRect);}ControlPartCode HandleTest(short varCode, ControlHandle theControl, Point *pos) {	if (PtInRect(*pos, &(**theControl).contrlRect)) {		return kControlButtonPart;	}		return kControlNoPart;}void HandleCalculateControlRegion(short varCode, ControlHandle theControl, RgnHandle destRegion) {	RectRgn(destRegion, &(**theControl).contrlRect);}void HandleCalculateIndicatorRegion(short varCode, ControlHandle theControl, RgnHandle destRegion) {	SetEmptyRgn(destRegion);}void HandleInit(short varCode, ControlHandle theControl) {	ListControlDataHandle dataHandle = (ListControlDataHandle) NewHandleClear(sizeof(struct ListControlData));	Rect listRect = (**theControl).contrlRect;	Rect dataBounds = { 0, 0, 3, 1 };	Point cellSize = { 0, 0 }; // Let list Mgr. calc.	ListHandle list = NULL;	const char* str = NULL;	Point cell = { 0, 0 };		listRect.right -= 15; // Leave room for scroll bar.	list = LNew(&listRect, &dataBounds, cellSize, 0, (**theControl).contrlOwner, false, false, false, true);	str = "First Row";	LSetCell(str, strlen(str), cell, list);	str = "Second Row";	cell.v = 1;	LSetCell(str, strlen(str), cell, list);	str = "third Row";	cell.v = 2;	LSetCell(str, strlen(str), cell, list);	(**dataHandle).list = list;	(**theControl).contrlData = (Handle)dataHandle;}void HandleDispose(short varCode, ControlHandle theControl) {	ListControlDataHandle dataHandle = (ListControlDataHandle) (**theControl).contrlData;	LDispose((**dataHandle).list);	DisposeHandle((**theControl).contrlData);}ControlPartCode HandleMoveIndicator(short varCode, ControlHandle theControl, Point *pos) {	// Move indicator by pos, update (**theControl).contrlValue here for the new location.}void HandleCalcThumbDragInfo(short varCode, ControlHandle theControl, Point *clickPos, IndicatorDragConstraint *dragInfo) {	}void HandleAutoTrack(short varCode, ControlHandle theControl, short partCode) {}pascal long main(short varCode, ControlHandle theControl, short message, long param) {	switch (message) {		case drawCntl:			if ((**theControl).contrlVis) {				HandleDraw(varCode, theControl, LoWord(param));			}			break;		case testCntl:			if ((**theControl).contrlVis && (**theControl).contrlHilite != kControlInactivePart) {				return HandleTest(varCode, theControl, (Point*) &param);			} else {				return kControlNoPart;			}			break;		case calcCRgns: {			UInt32 cleanParam = (UInt32) param;			if (cleanParam & 0x80000000L) {				cleanParam &= 0x7FFFFFFFL;				HandleCalculateIndicatorRegion(varCode, theControl, (RgnHandle) cleanParam);			} else {				HandleCalculateControlRegion(varCode, theControl, (RgnHandle) cleanParam);			}			break;		}				case initCntl:			HandleInit(varCode, theControl);			break;		case dispCntl:			HandleDispose(varCode, theControl);			break;		case posCntl:			HandleMoveIndicator(varCode, theControl, (Point*) &param);			break;		case thumbCntl: {			IndicatorDragConstraint *dragInfo = (IndicatorDragConstraint*) param;			Point *clickPos = (Point*) &dragInfo->limitRect.top;			HandleCalcThumbDragInfo(varCode, theControl, clickPos, dragInfo);			break;		}				case dragCntl:			return 0; // Get default control tracking with a grey region.			break;		case autoTrack:			HandleAutoTrack(varCode, theControl, LoWord(param));			break;		case calcCntlRgn:			HandleCalculateControlRegion(varCode, theControl, (RgnHandle) param);			break;		case calcThumbRgn:			HandleCalculateIndicatorRegion(varCode, theControl, (RgnHandle) param);			break;	}		return 0;}